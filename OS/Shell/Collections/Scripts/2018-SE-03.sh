# Напишете скрипт, който приема два позиционни аргумента – имена на текстови файлове формат
# Валидни са следните условия:
# • CSV файловете представляват таблица, като всеки ред на таблицата е записан на отделен ред;
# • на даден ред всяко поле (колона) е разделено от останалите със запетая;
# • броят наполетата на всеки ред е константа;
# • вполетата не можедаприсъства запетая, т.е., запетаята винаги е разделител между полета;
# • аковъвфайлаприсъстват интервали, то това са данни от дадено поле;
# • първото поле навсеки ред ечисло, което представлява идентификатор на реда (ID)
# Скриптът трябва да чете a.csv и на негова база да създава b.csv по следния начин:
# • някоиредове във файла серазличават само по колоната ID, и за тях казваме, че формират множество 𝐴𝑖
# • завсяко такова множество 𝐴𝑖 да се оставя само един ред- този, с най-малка стойност на ID-то;
# • редовете, които не са членове в някое множество 𝐴𝑖 се записват в изходния файл без промяна

#!/bin/bash

if [[ $# -ne 2 ]]; then
	echo "Exactly two args needed"
	exit 1
fi

READ_FILE=$1
RES_FILE=$2

if [[ ! -f "$READ_FILE" ]]; then
	echo "Read file is nonexistant"
	exit 2 
fi

DIR_PATH=$(dirname "$RES_FILE")
if [ ! -d "$DIR_PATH" ]; then
    mkdir -p "$DIR_PATH"
fi

if [[ ! -f "$RES_FILE" ]]; then
    touch "$RES_FILE"
else
    > "$RES_FILE"
fi

while read UNIQ_ROW; do
	ROW_UID=$(grep "$UNIQ_ROW$" "$READ_FILE" | sort -t ',' -k 1 -n | head -n 1 | cut -d ',' -f 1)
 	echo "${ROW_UID},${UNIQ_ROW}" >> $RES_FILE
done < <(sed -E "s/^[0-9]+,//"  "$READ_FILE" | sort | uniq)
